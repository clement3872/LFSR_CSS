class LFSR:
    def __init__(self,size, status, xor_list, last_output=None):
        """
        args:
            - status: a string of bits (int of 0 and 1)
            - xor_list: a list (or tuple), indicating where XOR are
            - last_output: if you have already done an LFSR, you can start at a specific status -> 0 or 1
                          else None
        """
        # some asserts for "security"
        assert type(status) is int, "`status` should be of type int (bin)"
        assert status > 0, "There should be a 1 in the list `status`"
        #assert type(size) is int and size>=status.bit_count(), "The size is wrong" # only after python 3.10

        self.size = size-1
        self.initial_status = status
        self.xor_list = []
        for el in xor_list:
            if el != 0:
                self.xor_list.append(el)
        self.xor_list.sort()

        self.current_status = self.initial_status
        self.last_output = last_output
        self.nb_iteration = 0
    
    def next(self):
        """Returns the next bit of the LFSR"""
        #print(self.nb_iteration, ": ", bin(self.current_status))
        self.last_output = 0b1 & self.current_status
        tmp = self.last_output
        
        for i in self.xor_list:
            tmp = ((self.current_status >> i) & 0b1 ) ^ tmp # `^` is a XOR
        
        # shifting the list
        self.current_status = (self.current_status >> 1) + tmp*(1 << self.size)
        self.nb_iteration += 1

        return self.last_output
    
    def next_byte(self):
        """Returns the next byte of the lfsr """
        x = 0
        for i in range(8):
            x += self.next() << i
        return x
    
    def reset(self):
        self.current_status = self.initial_status
        self.last_output = None
        self.nb_iteration = 0
    
    def check_duplicates(self):
        """
        Returns: Check if there is a cycle before 2^n - 1 iterations
        """
        # check duplicates
        old_last_output = self.last_output # we have to back up this
        start = self.current_status
        for i in range(2**(self.size+1) - 2): # First one is included
            self.next()
            if self.current_status == start:
                print("There is a duplicate at iteration number",i+1)
                print("start:", start)
                print("xor_list:", self.xor_list)
                print("current_status", self.current_status)
                # reset status
                self.last_output = old_last_output
                self.current_status = start
                self.nb_iteration -= i
                return False
        # reset status
        self.last_output = old_last_output
        self.current_status = start
        self.nb_iteration -= i
        return True


class CSS:
    def __init__(self, lfsr1, lfsr2):
        self.lfsr1 = lfsr1
        self.lfsr2 = lfsr2
        self.c = 0
    
    
    def reset(self):
        self.lfsr1.reset()
        self.lfsr2.reset()
        self.c = 0
    
    def next(self):
        """Returns the 8 next bits of the CSS as an int"""
        x = self.lfsr1.next_byte()
        y = self.lfsr2.next_byte()

        z = (x+y+self.c)%256

        self.c = 1 if x+y>255 else 0
        return z
    def encode(self, m):
        """
        `m` must be a string composed by numbers in hexadecimal (0<m<ff)
        AND len(m) must be even
        -
        It does not use `next` function, it's faster
        """
        res = 0 
        for i in range(len(m)//2):
            x = self.next()
            res = (res<<8) +x# self.next()

        self.reset()
        return hex(res^int(m,16))[2:]
    
    def decode(self, c):
        # It's symmetrical
        return self.encode(c)




class Attack:
    def __init__(self, input):
    
        """
        The input is a list of 6 bytes generated by the CSS
        """
        self.z_1 = input[0]
        self.z_2 = input[1]
        self.z_3 = input[2]
        self.z_4 = input[3]
        self.z_5 = input[4]
        self.z_6 = input[5]
        

        self.xor_list_17 = (14,0)
        self.xor_list_25 = (12,4,3,0)
    


    def start(self):
        debug = 0
        # We are testing every possibilities of the 17 bits lfsr initial state
        for i in range(0b1111111111111111 + 1):
            # the first bit is always 1
            reg = (1 << 16) | i
            # Saving the initial state of the 17 lfsr so we can use it in the css later to test output
            tmp17 = LFSR(17, reg, self.xor_list_17)
            curr_lfsr = LFSR(17, reg, self.xor_list_17)
            # Clocking out 4 bytes from the current 17bits lfsr
            x_1 = curr_lfsr.next_byte()  
            x_2 = curr_lfsr.next_byte()
            x_3 = curr_lfsr.next_byte()
            x_4 = curr_lfsr.next_byte()
            # Finding out the 25bits lfsr output

            c = 0

            y_1 = (self.z_1 - x_1 - c + 256) % 256
            c = 1 if (x_1 + y_1 + c) > 255 else 0
            y_2 = (self.z_2 - x_2 - c + 256) % 256
            c = 1 if (x_2 + y_2 + c) > 255 else 0
            y_3 = (self.z_3 - x_3 - c + 256) % 256
            c = 1 if (x_3 + y_3 + c) > 255 else 0
            y_4 = (self.z_4 - x_4 - c + 256) % 256

            y = (y_4 << 24) | (y_3 << 16) | (y_2 << 8) | y_1 
            

            # Finding the 25bits lfsr initial state
            # knowing that the register is 25 long and we know 32 output bit,
            # the initial state are just the 25 latest bits reverted
            initial_state = y & (0x1FFFFFF)
            curr_lfsr25 = LFSR(25, initial_state, self.xor_list_25)
            # Comparing every output
            
            css = CSS(tmp17, curr_lfsr25)
            test_z1 = css.next()
            test_z2 = css.next()
            test_z3 = css.next()
            test_z4 = css.next()
            test_z5 = css.next()
            test_z6 = css.next()
            
            if (   
                    test_z1 == self.z_1  and 
                    test_z2 == self.z_2  and 
                    test_z3 == self.z_3  and 
                    test_z4 == self.z_4  and 
                    test_z5 == self.z_5  and 
                    test_z6 == self.z_6 
                ):
                print("============================================================")
                print("A key was found !: ")
                print("lfsr-17 initial state: ", bin(reg), "(", reg, ")")
                print("lfsr-25 initial state: ", bin(initial_state), "(", initial_state, ")")
                print("============================================================")
                fullkey_2bytes = reg & 0xFFFF
                fullkey_4bytes = initial_state & 0xFFFFFF
                fullkey = fullkey_2bytes << 24 | fullkey_4bytes
                #print("Full key: ", bin(fullkey))
                return fullkey
        return None


######### TESTINT PART

def test0():
    # First example from the PDF (on 8 bits)
    start = 0b10010110
    xor_list = (2,3,4)
    l = LFSR(8,start, xor_list)
    l.check_duplicates()

def test1():
    """
    Example for an LFSR of 17 bits.
    This may take a bit of time.
    (question 1)
    """
    n = 17
    start = 1 << (n-1) #"1" + (n-1)*"0"
    xor_list = (14,0)

    l = LFSR(n, start, xor_list) 
    l.check_duplicates()

def test2():
    """
    Example for an LFSR of 25 bits.
    This may take even more time than for 17 bits.
    (question 2)
    """
    n = 25
    start = 1 << (n-1) 
    xor_list = (12,4,3,0)

    l = LFSR(n, start, xor_list) 
    l.check_duplicates()


def test3():
    """
    (question 3)
    """
    n = 17
    start = 1 << (n-1) 
    xor_list = (14,0)
    l1 = LFSR(n, start, xor_list) 

    n = 25
    start = 1 << (n-1) 
    xor_list = (12,4,3,0)
    l2 = LFSR(n, start, xor_list) 

    css = CSS(l1,l2)
    m = "ffffffffff"

    print(f"The message: {m}")

    c = css.encode(m)
    print(f"Encoded message: {c}")
    print(f"Decoding the encoded message: {css.decode(c)}") # verification



import time
import random as rd
def testattack():
    init = rd.randint(0, 0b1111111111111111111111111111111111111111)
    print("Random value: ")
    print("============================================================")
    print("initialisation: ", bin(init), "(", init, ")")
    init17 = (1 << 16) | (init >> 24)
    
    init25 = (1 << 24) | init & 0xFFFFFF
    lfsr17 = LFSR(17, init17, (14,0))
    lfsr25 = LFSR(25, init25, (12,4,3,0))
    print("initialisation17: ", bin(init17), "(", init17,")")
    print("initialisation25: ", bin(init25), "(", init25,")")
    time.sleep(3)
    css = CSS(lfsr17, lfsr25)

    # Information known by the attacker, the first 6 output bytes
    z_1 = css.next()
    z_2 = css.next()
    z_3 = css.next()
    z_4 = css.next()
    z_5 = css.next()
    z_6 = css.next()

    at = Attack([z_1, z_2, z_3, z_4, z_5, z_6])
    print("============================================================")
    print("Starting attack simulation: ")
    res = at.start()
    if res == init:
        print("Key found: ", bin(res), "(", res, ")")
        print("============================================================")
    else:
        print("No key was found.")

if __name__ == "__main__":
    # NOTE : not every LFSR have a "cycle" of 2^n - 1 iterations 

    # test0()
    # test1()
    # test2()
    # test3()

    import time
    t0 = time.perf_counter()
    testattack()

    t1 = time.perf_counter()
    print("Execution time: ", t1 - t0)
